import { DefaultLogger, makeTelemetryFilterString, Runtime, Worker } from '@temporalio/worker';
import * as activities from './activities';
import { createLogger } from './logging';

const winstonLogger = createLogger({
  isProduction: process.env.NODE_ENV === 'production',
  logFilePath: process.env.WORKER_LOG_PATH || '/var/log/worker.log',
});

async function main() {
  // @@@SNIPSTART typescript-core-telemetry-options
  // Configure Rust Core runtime to export SDK logs
  Runtime.install({
    // Install a logger to collect logs generated by Node.js Workers and Rust Core.
    // Note: In production, WARN should generally be enough. DEBUG is quite verbose.
    logger: new DefaultLogger('DEBUG', (entry) => {
      winstonLogger.log({
        label: entry.meta?.activityId ? 'activity' : entry.meta?.workflowId ? 'workflow' : 'worker',
        level: entry.level.toLowerCase(),
        message: entry.message,
        timestamp: Number(entry.timestampNanos / 1_000_000n),
        ...entry.meta,
      });
    }),
    // Telemetry options control how logs are exported out of Rust Core.
    telemetryOptions: {
      logging: {
        // By default, Core logs go directly to console. Setting the `forward` property here (to an
        // empty object) enables forwarding of logs from Rust Core to the Node.js logger.
        forward: {},
        // This filter determines which logs should be forwarded from Rust Core to the Node.js logger.
        // Note: In production, WARN should generally be enough. DEBUG is quite verbose.
        filter: makeTelemetryFilterString({ core: 'DEBUG' }),
      },
    },
  });
  // @@@SNIPEND

  // Create a worker that uses the Runtime instance installed above
  const worker = await Worker.create({
    workflowsPath: require.resolve('./workflows'),
    activities,
    taskQueue: 'custom-logger',
  });
  await worker.run();
}

main().then(
  () => void process.exit(0),
  (err) => {
    winstonLogger.error('Process failed', err);
    process.exit(1);
  }
);
